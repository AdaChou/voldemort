// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_voldemort_2dclient_2eproto__INCLUDED
#define PROTOBUF_voldemort_2dclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace voldemort {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_voldemort_2dclient_2eproto();
void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class ClockEntry;
class VectorClock;
class Versioned;
class Error;
class KeyedVersions;
class GetRequest;
class GetResponse;
class GetAllRequest;
class GetAllResponse;
class PutRequest;
class PutResponse;
class DeleteRequest;
class DeleteResponse;
class VoldemortRequest;

enum RequestType {
  GET = 0,
  GET_ALL = 1,
  PUT = 2,
  DELETE = 3
};
const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = GET;
const RequestType RequestType_MAX = DELETE;

// ===================================================================

class ClockEntry : public ::google::protobuf::Message {
 public:
  ClockEntry();
  virtual ~ClockEntry();
  
  ClockEntry(const ClockEntry& from);
  
  inline ClockEntry& operator=(const ClockEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClockEntry& default_instance();
  void Swap(ClockEntry* other);
  
  // implements Message ----------------------------------------------
  
  ClockEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClockEntry& from);
  void MergeFrom(const ClockEntry& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);
  
  // required int64 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  inline ::google::protobuf::int64 version() const;
  inline void set_version(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int64 version_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ClockEntry* default_instance_;
};
// -------------------------------------------------------------------

class VectorClock : public ::google::protobuf::Message {
 public:
  VectorClock();
  virtual ~VectorClock();
  
  VectorClock(const VectorClock& from);
  
  inline VectorClock& operator=(const VectorClock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VectorClock& default_instance();
  void Swap(VectorClock* other);
  
  // implements Message ----------------------------------------------
  
  VectorClock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VectorClock& from);
  void MergeFrom(const VectorClock& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .voldemort.ClockEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::voldemort::ClockEntry >& entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::voldemort::ClockEntry >* mutable_entries();
  inline const ::voldemort::ClockEntry& entries(int index) const;
  inline ::voldemort::ClockEntry* mutable_entries(int index);
  inline ::voldemort::ClockEntry* add_entries();
  
  // optional int64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::voldemort::ClockEntry > entries_;
  ::google::protobuf::int64 timestamp_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VectorClock* default_instance_;
};
// -------------------------------------------------------------------

class Versioned : public ::google::protobuf::Message {
 public:
  Versioned();
  virtual ~Versioned();
  
  Versioned(const Versioned& from);
  
  inline Versioned& operator=(const Versioned& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Versioned& default_instance();
  void Swap(Versioned* other);
  
  // implements Message ----------------------------------------------
  
  Versioned* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Versioned& from);
  void MergeFrom(const Versioned& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes value = 1;
  inline bool has_value() const;
  inline void clear_value();
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  
  // required .voldemort.VectorClock version = 2;
  inline bool has_version() const;
  inline void clear_version();
  inline const ::voldemort::VectorClock& version() const;
  inline ::voldemort::VectorClock* mutable_version();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::voldemort::VectorClock* version_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Versioned* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);
  
  // required string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline ::std::string* mutable_error_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 error_code_;
  ::std::string* error_message_;
  static const ::std::string _default_error_message_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class KeyedVersions : public ::google::protobuf::Message {
 public:
  KeyedVersions();
  virtual ~KeyedVersions();
  
  KeyedVersions(const KeyedVersions& from);
  
  inline KeyedVersions& operator=(const KeyedVersions& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyedVersions& default_instance();
  void Swap(KeyedVersions* other);
  
  // implements Message ----------------------------------------------
  
  KeyedVersions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyedVersions& from);
  void MergeFrom(const KeyedVersions& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // repeated .voldemort.Versioned versions = 2;
  inline int versions_size() const;
  inline void clear_versions();
  inline const ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >& versions() const;
  inline ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >* mutable_versions();
  inline const ::voldemort::Versioned& versions(int index) const;
  inline ::voldemort::Versioned* mutable_versions(int index);
  inline ::voldemort::Versioned* add_versions();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned > versions_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KeyedVersions* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message {
 public:
  GetRequest();
  virtual ~GetRequest();
  
  GetRequest(const GetRequest& from);
  
  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();
  void Swap(GetRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message {
 public:
  GetResponse();
  virtual ~GetResponse();
  
  GetResponse(const GetResponse& from);
  
  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();
  void Swap(GetResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .voldemort.Versioned versioned = 1;
  inline int versioned_size() const;
  inline void clear_versioned();
  inline const ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >& versioned() const;
  inline ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >* mutable_versioned();
  inline const ::voldemort::Versioned& versioned(int index) const;
  inline ::voldemort::Versioned* mutable_versioned(int index);
  inline ::voldemort::Versioned* add_versioned();
  
  // optional .voldemort.Error error = 2;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::voldemort::Error& error() const;
  inline ::voldemort::Error* mutable_error();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned > versioned_;
  ::voldemort::Error* error_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAllRequest : public ::google::protobuf::Message {
 public:
  GetAllRequest();
  virtual ~GetAllRequest();
  
  GetAllRequest(const GetAllRequest& from);
  
  inline GetAllRequest& operator=(const GetAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllRequest& default_instance();
  void Swap(GetAllRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetAllRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllRequest& from);
  void MergeFrom(const GetAllRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline void add_keys(const void* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAllResponse : public ::google::protobuf::Message {
 public:
  GetAllResponse();
  virtual ~GetAllResponse();
  
  GetAllResponse(const GetAllResponse& from);
  
  inline GetAllResponse& operator=(const GetAllResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllResponse& default_instance();
  void Swap(GetAllResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetAllResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllResponse& from);
  void MergeFrom(const GetAllResponse& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .voldemort.KeyedVersions values = 1;
  inline int values_size() const;
  inline void clear_values();
  inline const ::google::protobuf::RepeatedPtrField< ::voldemort::KeyedVersions >& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::voldemort::KeyedVersions >* mutable_values();
  inline const ::voldemort::KeyedVersions& values(int index) const;
  inline ::voldemort::KeyedVersions* mutable_values(int index);
  inline ::voldemort::KeyedVersions* add_values();
  
  // optional .voldemort.Error error = 2;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::voldemort::Error& error() const;
  inline ::voldemort::Error* mutable_error();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::voldemort::KeyedVersions > values_;
  ::voldemort::Error* error_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetAllResponse* default_instance_;
};
// -------------------------------------------------------------------

class PutRequest : public ::google::protobuf::Message {
 public:
  PutRequest();
  virtual ~PutRequest();
  
  PutRequest(const PutRequest& from);
  
  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutRequest& default_instance();
  void Swap(PutRequest* other);
  
  // implements Message ----------------------------------------------
  
  PutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required .voldemort.Versioned versioned = 2;
  inline bool has_versioned() const;
  inline void clear_versioned();
  inline const ::voldemort::Versioned& versioned() const;
  inline ::voldemort::Versioned* mutable_versioned();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::voldemort::Versioned* versioned_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PutRequest* default_instance_;
};
// -------------------------------------------------------------------

class PutResponse : public ::google::protobuf::Message {
 public:
  PutResponse();
  virtual ~PutResponse();
  
  PutResponse(const PutResponse& from);
  
  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PutResponse& default_instance();
  void Swap(PutResponse* other);
  
  // implements Message ----------------------------------------------
  
  PutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .voldemort.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::voldemort::Error& error() const;
  inline ::voldemort::Error* mutable_error();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::voldemort::Error* error_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PutResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();
  
  DeleteRequest(const DeleteRequest& from);
  
  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();
  void Swap(DeleteRequest* other);
  
  // implements Message ----------------------------------------------
  
  DeleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required .voldemort.VectorClock version = 2;
  inline bool has_version() const;
  inline void clear_version();
  inline const ::voldemort::VectorClock& version() const;
  inline ::voldemort::VectorClock* mutable_version();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::voldemort::VectorClock* version_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();
  
  DeleteResponse(const DeleteResponse& from);
  
  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();
  void Swap(DeleteResponse* other);
  
  // implements Message ----------------------------------------------
  
  DeleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional .voldemort.Error error = 2;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::voldemort::Error& error() const;
  inline ::voldemort::Error* mutable_error();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool success_;
  ::voldemort::Error* error_;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class VoldemortRequest : public ::google::protobuf::Message {
 public:
  VoldemortRequest();
  virtual ~VoldemortRequest();
  
  VoldemortRequest(const VoldemortRequest& from);
  
  inline VoldemortRequest& operator=(const VoldemortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VoldemortRequest& default_instance();
  void Swap(VoldemortRequest* other);
  
  // implements Message ----------------------------------------------
  
  VoldemortRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoldemortRequest& from);
  void MergeFrom(const VoldemortRequest& from);
  void Clear();
  bool IsInitialized() const;
  int ByteSize() const;
  
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  bool SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .voldemort.RequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  inline voldemort::RequestType type() const;
  inline void set_type(voldemort::RequestType value);
  
  // required bool should_route = 2 [default = false];
  inline bool has_should_route() const;
  inline void clear_should_route();
  inline bool should_route() const;
  inline void set_should_route(bool value);
  
  // required string store = 3;
  inline bool has_store() const;
  inline void clear_store();
  inline const ::std::string& store() const;
  inline void set_store(const ::std::string& value);
  inline void set_store(const char* value);
  inline ::std::string* mutable_store();
  
  // optional .voldemort.GetRequest get = 4;
  inline bool has_get() const;
  inline void clear_get();
  inline const ::voldemort::GetRequest& get() const;
  inline ::voldemort::GetRequest* mutable_get();
  
  // optional .voldemort.GetAllRequest getAll = 5;
  inline bool has_getall() const;
  inline void clear_getall();
  inline const ::voldemort::GetAllRequest& getall() const;
  inline ::voldemort::GetAllRequest* mutable_getall();
  
  // optional .voldemort.PutRequest put = 6;
  inline bool has_put() const;
  inline void clear_put();
  inline const ::voldemort::PutRequest& put() const;
  inline ::voldemort::PutRequest* mutable_put();
  
  // optional .voldemort.DeleteRequest delete = 7;
  inline bool has_delete_() const;
  inline void clear_delete_();
  inline const ::voldemort::DeleteRequest& delete_() const;
  inline ::voldemort::DeleteRequest* mutable_delete_();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  bool should_route_;
  ::std::string* store_;
  static const ::std::string _default_store_;
  ::voldemort::GetRequest* get_;
  ::voldemort::GetAllRequest* getall_;
  ::voldemort::PutRequest* put_;
  ::voldemort::DeleteRequest* delete__;
  friend void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VoldemortRequest* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// ClockEntry

// required int32 node_id = 1;
inline bool ClockEntry::has_node_id() const {
  return _has_bit(0);
}
inline void ClockEntry::clear_node_id() {
  node_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ClockEntry::node_id() const {
  return node_id_;
}
inline void ClockEntry::set_node_id(::google::protobuf::int32 value) {
  _set_bit(0);
  node_id_ = value;
}

// required int64 version = 2;
inline bool ClockEntry::has_version() const {
  return _has_bit(1);
}
inline void ClockEntry::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 ClockEntry::version() const {
  return version_;
}
inline void ClockEntry::set_version(::google::protobuf::int64 value) {
  _set_bit(1);
  version_ = value;
}

// -------------------------------------------------------------------

// VectorClock

// repeated .voldemort.ClockEntry entries = 1;
inline int VectorClock::entries_size() const {
  return entries_.size();
}
inline void VectorClock::clear_entries() {
  entries_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::voldemort::ClockEntry >&
VectorClock::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::voldemort::ClockEntry >*
VectorClock::mutable_entries() {
  return &entries_;
}
inline const ::voldemort::ClockEntry& VectorClock::entries(int index) const {
  return entries_.Get(index);
}
inline ::voldemort::ClockEntry* VectorClock::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::voldemort::ClockEntry* VectorClock::add_entries() {
  return entries_.Add();
}

// optional int64 timestamp = 2;
inline bool VectorClock::has_timestamp() const {
  return _has_bit(1);
}
inline void VectorClock::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 VectorClock::timestamp() const {
  return timestamp_;
}
inline void VectorClock::set_timestamp(::google::protobuf::int64 value) {
  _set_bit(1);
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Versioned

// required bytes value = 1;
inline bool Versioned::has_value() const {
  return _has_bit(0);
}
inline void Versioned::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Versioned::value() const {
  return *value_;
}
inline void Versioned::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Versioned::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Versioned::set_value(const void* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Versioned::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// required .voldemort.VectorClock version = 2;
inline bool Versioned::has_version() const {
  return _has_bit(1);
}
inline void Versioned::clear_version() {
  if (version_ != NULL) version_->::voldemort::VectorClock::Clear();
  _clear_bit(1);
}
inline const ::voldemort::VectorClock& Versioned::version() const {
  return version_ != NULL ? *version_ : *default_instance_->version_;
}
inline ::voldemort::VectorClock* Versioned::mutable_version() {
  _set_bit(1);
  if (version_ == NULL) version_ = new ::voldemort::VectorClock;
  return version_;
}

// -------------------------------------------------------------------

// Error

// required int32 error_code = 1;
inline bool Error::has_error_code() const {
  return _has_bit(0);
}
inline void Error::clear_error_code() {
  error_code_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Error::error_code() const {
  return error_code_;
}
inline void Error::set_error_code(::google::protobuf::int32 value) {
  _set_bit(0);
  error_code_ = value;
}

// required string error_message = 2;
inline bool Error::has_error_message() const {
  return _has_bit(1);
}
inline void Error::clear_error_message() {
  if (error_message_ != &_default_error_message_) {
    error_message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Error::error_message() const {
  return *error_message_;
}
inline void Error::set_error_message(const ::std::string& value) {
  _set_bit(1);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void Error::set_error_message(const char* value) {
  _set_bit(1);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline ::std::string* Error::mutable_error_message() {
  _set_bit(1);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}

// -------------------------------------------------------------------

// KeyedVersions

// required bytes key = 1;
inline bool KeyedVersions::has_key() const {
  return _has_bit(0);
}
inline void KeyedVersions::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& KeyedVersions::key() const {
  return *key_;
}
inline void KeyedVersions::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyedVersions::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyedVersions::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyedVersions::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// repeated .voldemort.Versioned versions = 2;
inline int KeyedVersions::versions_size() const {
  return versions_.size();
}
inline void KeyedVersions::clear_versions() {
  versions_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >&
KeyedVersions::versions() const {
  return versions_;
}
inline ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >*
KeyedVersions::mutable_versions() {
  return &versions_;
}
inline const ::voldemort::Versioned& KeyedVersions::versions(int index) const {
  return versions_.Get(index);
}
inline ::voldemort::Versioned* KeyedVersions::mutable_versions(int index) {
  return versions_.Mutable(index);
}
inline ::voldemort::Versioned* KeyedVersions::add_versions() {
  return versions_.Add();
}

// -------------------------------------------------------------------

// GetRequest

// optional bytes key = 1;
inline bool GetRequest::has_key() const {
  return _has_bit(0);
}
inline void GetRequest::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetRequest::key() const {
  return *key_;
}
inline void GetRequest::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void GetRequest::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void GetRequest::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRequest::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// -------------------------------------------------------------------

// GetResponse

// repeated .voldemort.Versioned versioned = 1;
inline int GetResponse::versioned_size() const {
  return versioned_.size();
}
inline void GetResponse::clear_versioned() {
  versioned_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >&
GetResponse::versioned() const {
  return versioned_;
}
inline ::google::protobuf::RepeatedPtrField< ::voldemort::Versioned >*
GetResponse::mutable_versioned() {
  return &versioned_;
}
inline const ::voldemort::Versioned& GetResponse::versioned(int index) const {
  return versioned_.Get(index);
}
inline ::voldemort::Versioned* GetResponse::mutable_versioned(int index) {
  return versioned_.Mutable(index);
}
inline ::voldemort::Versioned* GetResponse::add_versioned() {
  return versioned_.Add();
}

// optional .voldemort.Error error = 2;
inline bool GetResponse::has_error() const {
  return _has_bit(1);
}
inline void GetResponse::clear_error() {
  if (error_ != NULL) error_->::voldemort::Error::Clear();
  _clear_bit(1);
}
inline const ::voldemort::Error& GetResponse::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::voldemort::Error* GetResponse::mutable_error() {
  _set_bit(1);
  if (error_ == NULL) error_ = new ::voldemort::Error;
  return error_;
}

// -------------------------------------------------------------------

// GetAllRequest

// repeated bytes keys = 1;
inline int GetAllRequest::keys_size() const {
  return keys_.size();
}
inline void GetAllRequest::clear_keys() {
  keys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetAllRequest::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetAllRequest::mutable_keys() {
  return &keys_;
}
inline const ::std::string& GetAllRequest::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* GetAllRequest::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void GetAllRequest::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void GetAllRequest::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline ::std::string* GetAllRequest::add_keys() {
  return keys_.Add();
}
inline void GetAllRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void GetAllRequest::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void GetAllRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void GetAllRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// GetAllResponse

// repeated .voldemort.KeyedVersions values = 1;
inline int GetAllResponse::values_size() const {
  return values_.size();
}
inline void GetAllResponse::clear_values() {
  values_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::voldemort::KeyedVersions >&
GetAllResponse::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::voldemort::KeyedVersions >*
GetAllResponse::mutable_values() {
  return &values_;
}
inline const ::voldemort::KeyedVersions& GetAllResponse::values(int index) const {
  return values_.Get(index);
}
inline ::voldemort::KeyedVersions* GetAllResponse::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::voldemort::KeyedVersions* GetAllResponse::add_values() {
  return values_.Add();
}

// optional .voldemort.Error error = 2;
inline bool GetAllResponse::has_error() const {
  return _has_bit(1);
}
inline void GetAllResponse::clear_error() {
  if (error_ != NULL) error_->::voldemort::Error::Clear();
  _clear_bit(1);
}
inline const ::voldemort::Error& GetAllResponse::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::voldemort::Error* GetAllResponse::mutable_error() {
  _set_bit(1);
  if (error_ == NULL) error_ = new ::voldemort::Error;
  return error_;
}

// -------------------------------------------------------------------

// PutRequest

// required bytes key = 1;
inline bool PutRequest::has_key() const {
  return _has_bit(0);
}
inline void PutRequest::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PutRequest::key() const {
  return *key_;
}
inline void PutRequest::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void PutRequest::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void PutRequest::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PutRequest::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required .voldemort.Versioned versioned = 2;
inline bool PutRequest::has_versioned() const {
  return _has_bit(1);
}
inline void PutRequest::clear_versioned() {
  if (versioned_ != NULL) versioned_->::voldemort::Versioned::Clear();
  _clear_bit(1);
}
inline const ::voldemort::Versioned& PutRequest::versioned() const {
  return versioned_ != NULL ? *versioned_ : *default_instance_->versioned_;
}
inline ::voldemort::Versioned* PutRequest::mutable_versioned() {
  _set_bit(1);
  if (versioned_ == NULL) versioned_ = new ::voldemort::Versioned;
  return versioned_;
}

// -------------------------------------------------------------------

// PutResponse

// optional .voldemort.Error error = 1;
inline bool PutResponse::has_error() const {
  return _has_bit(0);
}
inline void PutResponse::clear_error() {
  if (error_ != NULL) error_->::voldemort::Error::Clear();
  _clear_bit(0);
}
inline const ::voldemort::Error& PutResponse::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::voldemort::Error* PutResponse::mutable_error() {
  _set_bit(0);
  if (error_ == NULL) error_ = new ::voldemort::Error;
  return error_;
}

// -------------------------------------------------------------------

// DeleteRequest

// required bytes key = 1;
inline bool DeleteRequest::has_key() const {
  return _has_bit(0);
}
inline void DeleteRequest::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteRequest::key() const {
  return *key_;
}
inline void DeleteRequest::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void DeleteRequest::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void DeleteRequest::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required .voldemort.VectorClock version = 2;
inline bool DeleteRequest::has_version() const {
  return _has_bit(1);
}
inline void DeleteRequest::clear_version() {
  if (version_ != NULL) version_->::voldemort::VectorClock::Clear();
  _clear_bit(1);
}
inline const ::voldemort::VectorClock& DeleteRequest::version() const {
  return version_ != NULL ? *version_ : *default_instance_->version_;
}
inline ::voldemort::VectorClock* DeleteRequest::mutable_version() {
  _set_bit(1);
  if (version_ == NULL) version_ = new ::voldemort::VectorClock;
  return version_;
}

// -------------------------------------------------------------------

// DeleteResponse

// required bool success = 1;
inline bool DeleteResponse::has_success() const {
  return _has_bit(0);
}
inline void DeleteResponse::clear_success() {
  success_ = false;
  _clear_bit(0);
}
inline bool DeleteResponse::success() const {
  return success_;
}
inline void DeleteResponse::set_success(bool value) {
  _set_bit(0);
  success_ = value;
}

// optional .voldemort.Error error = 2;
inline bool DeleteResponse::has_error() const {
  return _has_bit(1);
}
inline void DeleteResponse::clear_error() {
  if (error_ != NULL) error_->::voldemort::Error::Clear();
  _clear_bit(1);
}
inline const ::voldemort::Error& DeleteResponse::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::voldemort::Error* DeleteResponse::mutable_error() {
  _set_bit(1);
  if (error_ == NULL) error_ = new ::voldemort::Error;
  return error_;
}

// -------------------------------------------------------------------

// VoldemortRequest

// required .voldemort.RequestType type = 1;
inline bool VoldemortRequest::has_type() const {
  return _has_bit(0);
}
inline void VoldemortRequest::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline voldemort::RequestType VoldemortRequest::type() const {
  return static_cast< voldemort::RequestType >(type_);
}
inline void VoldemortRequest::set_type(voldemort::RequestType value) {
  GOOGLE_DCHECK(voldemort::RequestType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// required bool should_route = 2 [default = false];
inline bool VoldemortRequest::has_should_route() const {
  return _has_bit(1);
}
inline void VoldemortRequest::clear_should_route() {
  should_route_ = false;
  _clear_bit(1);
}
inline bool VoldemortRequest::should_route() const {
  return should_route_;
}
inline void VoldemortRequest::set_should_route(bool value) {
  _set_bit(1);
  should_route_ = value;
}

// required string store = 3;
inline bool VoldemortRequest::has_store() const {
  return _has_bit(2);
}
inline void VoldemortRequest::clear_store() {
  if (store_ != &_default_store_) {
    store_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& VoldemortRequest::store() const {
  return *store_;
}
inline void VoldemortRequest::set_store(const ::std::string& value) {
  _set_bit(2);
  if (store_ == &_default_store_) {
    store_ = new ::std::string;
  }
  store_->assign(value);
}
inline void VoldemortRequest::set_store(const char* value) {
  _set_bit(2);
  if (store_ == &_default_store_) {
    store_ = new ::std::string;
  }
  store_->assign(value);
}
inline ::std::string* VoldemortRequest::mutable_store() {
  _set_bit(2);
  if (store_ == &_default_store_) {
    store_ = new ::std::string;
  }
  return store_;
}

// optional .voldemort.GetRequest get = 4;
inline bool VoldemortRequest::has_get() const {
  return _has_bit(3);
}
inline void VoldemortRequest::clear_get() {
  if (get_ != NULL) get_->::voldemort::GetRequest::Clear();
  _clear_bit(3);
}
inline const ::voldemort::GetRequest& VoldemortRequest::get() const {
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::voldemort::GetRequest* VoldemortRequest::mutable_get() {
  _set_bit(3);
  if (get_ == NULL) get_ = new ::voldemort::GetRequest;
  return get_;
}

// optional .voldemort.GetAllRequest getAll = 5;
inline bool VoldemortRequest::has_getall() const {
  return _has_bit(4);
}
inline void VoldemortRequest::clear_getall() {
  if (getall_ != NULL) getall_->::voldemort::GetAllRequest::Clear();
  _clear_bit(4);
}
inline const ::voldemort::GetAllRequest& VoldemortRequest::getall() const {
  return getall_ != NULL ? *getall_ : *default_instance_->getall_;
}
inline ::voldemort::GetAllRequest* VoldemortRequest::mutable_getall() {
  _set_bit(4);
  if (getall_ == NULL) getall_ = new ::voldemort::GetAllRequest;
  return getall_;
}

// optional .voldemort.PutRequest put = 6;
inline bool VoldemortRequest::has_put() const {
  return _has_bit(5);
}
inline void VoldemortRequest::clear_put() {
  if (put_ != NULL) put_->::voldemort::PutRequest::Clear();
  _clear_bit(5);
}
inline const ::voldemort::PutRequest& VoldemortRequest::put() const {
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::voldemort::PutRequest* VoldemortRequest::mutable_put() {
  _set_bit(5);
  if (put_ == NULL) put_ = new ::voldemort::PutRequest;
  return put_;
}

// optional .voldemort.DeleteRequest delete = 7;
inline bool VoldemortRequest::has_delete_() const {
  return _has_bit(6);
}
inline void VoldemortRequest::clear_delete_() {
  if (delete__ != NULL) delete__->::voldemort::DeleteRequest::Clear();
  _clear_bit(6);
}
inline const ::voldemort::DeleteRequest& VoldemortRequest::delete_() const {
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::voldemort::DeleteRequest* VoldemortRequest::mutable_delete_() {
  _set_bit(6);
  if (delete__ == NULL) delete__ = new ::voldemort::DeleteRequest;
  return delete__;
}


}  // namespace voldemort
#endif  // PROTOBUF_voldemort_2dclient_2eproto__INCLUDED
