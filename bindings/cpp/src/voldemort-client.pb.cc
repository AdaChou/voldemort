// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "voldemort-client.pb.h"
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format_inl.h>

namespace voldemort {

namespace {

const ::google::protobuf::Descriptor* ClockEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClockEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* VectorClock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VectorClock_reflection_ = NULL;
const ::google::protobuf::Descriptor* Versioned_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Versioned_reflection_ = NULL;
const ::google::protobuf::Descriptor* Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Error_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyedVersions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyedVersions_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetAllRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetAllRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetAllResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetAllResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* VoldemortRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VoldemortRequest_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RequestType_descriptor_ = NULL;

}  // namespace


void protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors(const ::google::protobuf::FileDescriptor* file) {
  ClockEntry_descriptor_ = file->message_type(0);
  ClockEntry::default_instance_ = new ClockEntry();
  static const int ClockEntry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClockEntry, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClockEntry, version_),
  };
  ClockEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClockEntry_descriptor_,
      ClockEntry::default_instance_,
      ClockEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClockEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClockEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(ClockEntry));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClockEntry_descriptor_, ClockEntry::default_instance_);
  VectorClock_descriptor_ = file->message_type(1);
  VectorClock::default_instance_ = new VectorClock();
  static const int VectorClock_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorClock, entries_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorClock, timestamp_),
  };
  VectorClock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VectorClock_descriptor_,
      VectorClock::default_instance_,
      VectorClock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorClock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VectorClock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(VectorClock));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VectorClock_descriptor_, VectorClock::default_instance_);
  Versioned_descriptor_ = file->message_type(2);
  Versioned::default_instance_ = new Versioned();
  static const int Versioned_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Versioned, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Versioned, version_),
  };
  Versioned_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Versioned_descriptor_,
      Versioned::default_instance_,
      Versioned_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Versioned, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Versioned, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(Versioned));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Versioned_descriptor_, Versioned::default_instance_);
  Error_descriptor_ = file->message_type(3);
  Error::default_instance_ = new Error();
  static const int Error_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, error_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, error_message_),
  };
  Error_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Error_descriptor_,
      Error::default_instance_,
      Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(Error));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Error_descriptor_, Error::default_instance_);
  KeyedVersions_descriptor_ = file->message_type(4);
  KeyedVersions::default_instance_ = new KeyedVersions();
  static const int KeyedVersions_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyedVersions, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyedVersions, versions_),
  };
  KeyedVersions_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyedVersions_descriptor_,
      KeyedVersions::default_instance_,
      KeyedVersions_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyedVersions, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyedVersions, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(KeyedVersions));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyedVersions_descriptor_, KeyedVersions::default_instance_);
  GetRequest_descriptor_ = file->message_type(5);
  GetRequest::default_instance_ = new GetRequest();
  static const int GetRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, key_),
  };
  GetRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetRequest_descriptor_,
      GetRequest::default_instance_,
      GetRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(GetRequest));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetRequest_descriptor_, GetRequest::default_instance_);
  GetResponse_descriptor_ = file->message_type(6);
  GetResponse::default_instance_ = new GetResponse();
  static const int GetResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, versioned_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, error_),
  };
  GetResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetResponse_descriptor_,
      GetResponse::default_instance_,
      GetResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(GetResponse));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetResponse_descriptor_, GetResponse::default_instance_);
  GetAllRequest_descriptor_ = file->message_type(7);
  GetAllRequest::default_instance_ = new GetAllRequest();
  static const int GetAllRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllRequest, keys_),
  };
  GetAllRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetAllRequest_descriptor_,
      GetAllRequest::default_instance_,
      GetAllRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(GetAllRequest));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetAllRequest_descriptor_, GetAllRequest::default_instance_);
  GetAllResponse_descriptor_ = file->message_type(8);
  GetAllResponse::default_instance_ = new GetAllResponse();
  static const int GetAllResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllResponse, values_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllResponse, error_),
  };
  GetAllResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetAllResponse_descriptor_,
      GetAllResponse::default_instance_,
      GetAllResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAllResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(GetAllResponse));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetAllResponse_descriptor_, GetAllResponse::default_instance_);
  PutRequest_descriptor_ = file->message_type(9);
  PutRequest::default_instance_ = new PutRequest();
  static const int PutRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, versioned_),
  };
  PutRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PutRequest_descriptor_,
      PutRequest::default_instance_,
      PutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(PutRequest));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PutRequest_descriptor_, PutRequest::default_instance_);
  PutResponse_descriptor_ = file->message_type(10);
  PutResponse::default_instance_ = new PutResponse();
  static const int PutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, error_),
  };
  PutResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PutResponse_descriptor_,
      PutResponse::default_instance_,
      PutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(PutResponse));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PutResponse_descriptor_, PutResponse::default_instance_);
  DeleteRequest_descriptor_ = file->message_type(11);
  DeleteRequest::default_instance_ = new DeleteRequest();
  static const int DeleteRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, version_),
  };
  DeleteRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeleteRequest_descriptor_,
      DeleteRequest::default_instance_,
      DeleteRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(DeleteRequest));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeleteRequest_descriptor_, DeleteRequest::default_instance_);
  DeleteResponse_descriptor_ = file->message_type(12);
  DeleteResponse::default_instance_ = new DeleteResponse();
  static const int DeleteResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, success_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, error_),
  };
  DeleteResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DeleteResponse_descriptor_,
      DeleteResponse::default_instance_,
      DeleteResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(DeleteResponse));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DeleteResponse_descriptor_, DeleteResponse::default_instance_);
  VoldemortRequest_descriptor_ = file->message_type(13);
  VoldemortRequest::default_instance_ = new VoldemortRequest();
  static const int VoldemortRequest_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, should_route_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, store_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, get_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, getall_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, delete__),
  };
  VoldemortRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VoldemortRequest_descriptor_,
      VoldemortRequest::default_instance_,
      VoldemortRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoldemortRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      sizeof(VoldemortRequest));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VoldemortRequest_descriptor_, VoldemortRequest::default_instance_);
  RequestType_descriptor_ = file->enum_type(0);
  ClockEntry::default_instance_->InitAsDefaultInstance();
  VectorClock::default_instance_->InitAsDefaultInstance();
  Versioned::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  KeyedVersions::default_instance_->InitAsDefaultInstance();
  GetRequest::default_instance_->InitAsDefaultInstance();
  GetResponse::default_instance_->InitAsDefaultInstance();
  GetAllRequest::default_instance_->InitAsDefaultInstance();
  GetAllResponse::default_instance_->InitAsDefaultInstance();
  PutRequest::default_instance_->InitAsDefaultInstance();
  PutResponse::default_instance_->InitAsDefaultInstance();
  DeleteRequest::default_instance_->InitAsDefaultInstance();
  DeleteResponse::default_instance_->InitAsDefaultInstance();
  VoldemortRequest::default_instance_->InitAsDefaultInstance();
}

void protobuf_BuildDesc_voldemort_2dclient_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;
  ::google::protobuf::DescriptorPool* pool =
    ::google::protobuf::DescriptorPool::internal_generated_pool();

  pool->InternalBuildGeneratedFile(
    "\n\026voldemort-client.proto\022\tvoldemort\".\n\nC"
    "lockEntry\022\017\n\007node_id\030\001 \002(\005\022\017\n\007version\030\002 "
    "\002(\003\"H\n\013VectorClock\022&\n\007entries\030\001 \003(\0132\025.vo"
    "ldemort.ClockEntry\022\021\n\ttimestamp\030\002 \001(\003\"C\n"
    "\tVersioned\022\r\n\005value\030\001 \002(\014\022\'\n\007version\030\002 \002"
    "(\0132\026.voldemort.VectorClock\"2\n\005Error\022\022\n\ne"
    "rror_code\030\001 \002(\005\022\025\n\rerror_message\030\002 \002(\t\"D"
    "\n\rKeyedVersions\022\013\n\003key\030\001 \002(\014\022&\n\010versions"
    "\030\002 \003(\0132\024.voldemort.Versioned\"\031\n\nGetReque"
    "st\022\013\n\003key\030\001 \001(\014\"W\n\013GetResponse\022\'\n\tversio"
    "ned\030\001 \003(\0132\024.voldemort.Versioned\022\037\n\005error"
    "\030\002 \001(\0132\020.voldemort.Error\"\035\n\rGetAllReques"
    "t\022\014\n\004keys\030\001 \003(\014\"[\n\016GetAllResponse\022(\n\006val"
    "ues\030\001 \003(\0132\030.voldemort.KeyedVersions\022\037\n\005e"
    "rror\030\002 \001(\0132\020.voldemort.Error\"B\n\nPutReque"
    "st\022\013\n\003key\030\001 \002(\014\022\'\n\tversioned\030\002 \002(\0132\024.vol"
    "demort.Versioned\".\n\013PutResponse\022\037\n\005error"
    "\030\001 \001(\0132\020.voldemort.Error\"E\n\rDeleteReques"
    "t\022\013\n\003key\030\001 \002(\014\022\'\n\007version\030\002 \002(\0132\026.voldem"
    "ort.VectorClock\"B\n\016DeleteResponse\022\017\n\007suc"
    "cess\030\001 \002(\010\022\037\n\005error\030\002 \001(\0132\020.voldemort.Er"
    "ror\"\200\002\n\020VoldemortRequest\022$\n\004type\030\001 \002(\0162\026"
    ".voldemort.RequestType\022\033\n\014should_route\030\002"
    " \002(\010:\005false\022\r\n\005store\030\003 \002(\t\022\"\n\003get\030\004 \001(\0132"
    "\025.voldemort.GetRequest\022(\n\006getAll\030\005 \001(\0132\030"
    ".voldemort.GetAllRequest\022\"\n\003put\030\006 \001(\0132\025."
    "voldemort.PutRequest\022(\n\006delete\030\007 \001(\0132\030.v"
    "oldemort.DeleteRequest*8\n\013RequestType\022\007\n"
    "\003GET\020\000\022\013\n\007GET_ALL\020\001\022\007\n\003PUT\020\002\022\n\n\006DELETE\020\003"
    "B!\n\025voldemort.protocol.pbB\006VProtoH\001", 1195,
  &protobuf_BuildDesc_voldemort_2dclient_2eproto_AssignGlobalDescriptors);
}

// Force BuildDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_voldemort_2dclient_2eproto {
  StaticDescriptorInitializer_voldemort_2dclient_2eproto() {
    protobuf_BuildDesc_voldemort_2dclient_2eproto();
  }
} static_descriptor_initializer_voldemort_2dclient_2eproto_;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor() {
  if (RequestType_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return RequestType_descriptor_;
}
bool RequestType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================



ClockEntry::ClockEntry()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    node_id_(0),
    version_(GOOGLE_LONGLONG(0)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void ClockEntry::InitAsDefaultInstance() {}

ClockEntry::ClockEntry(const ClockEntry& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    node_id_(0),
    version_(GOOGLE_LONGLONG(0)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

ClockEntry::~ClockEntry() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* ClockEntry::descriptor() {
  if (ClockEntry_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return ClockEntry_descriptor_;
}

const ClockEntry& ClockEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

ClockEntry* ClockEntry::default_instance_ = NULL;

ClockEntry* ClockEntry::New() const {
  return new ClockEntry;
}

void ClockEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    node_id_ = 0;
    version_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClockEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required int32 node_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &node_id_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }
      
      // required int64 version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_version:
        DO_(::google::protobuf::internal::WireFormat::ReadInt64(
              input, &version_));
        _set_bit(1);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool ClockEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required int32 node_id = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteInt32(1, this->node_id(), output));
  }
  
  // required int64 version = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteInt64(2, this->version(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int ClockEntry::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->node_id());
    }
    
    // required int64 version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int64Size(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ClockEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClockEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClockEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClockEntry::MergeFrom(const ClockEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_node_id(from.node_id());
    }
    if (from._has_bit(1)) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClockEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClockEntry::CopyFrom(const ClockEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClockEntry::Swap(ClockEntry* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool ClockEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* ClockEntry::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* ClockEntry::GetReflection() const {
  if (ClockEntry_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return ClockEntry_reflection_;
}

// ===================================================================



VectorClock::VectorClock()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    timestamp_(GOOGLE_LONGLONG(0)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void VectorClock::InitAsDefaultInstance() {}

VectorClock::VectorClock(const VectorClock& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    timestamp_(GOOGLE_LONGLONG(0)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

VectorClock::~VectorClock() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* VectorClock::descriptor() {
  if (VectorClock_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return VectorClock_descriptor_;
}

const VectorClock& VectorClock::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

VectorClock* VectorClock::default_instance_ = NULL;

VectorClock* VectorClock::New() const {
  return new VectorClock;
}

void VectorClock::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    timestamp_ = GOOGLE_LONGLONG(0);
  }
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VectorClock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // repeated .voldemort.ClockEntry entries = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_entries:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_entries()));
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectTag(16)) goto parse_timestamp;
        break;
      }
      
      // optional int64 timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_timestamp:
        DO_(::google::protobuf::internal::WireFormat::ReadInt64(
              input, &timestamp_));
        _set_bit(1);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool VectorClock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // repeated .voldemort.ClockEntry entries = 1;
  for (int i = 0; i < entries_.size(); i++) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->entries(i), output));
  }
  
  // optional int64 timestamp = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteInt64(2, this->timestamp(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int VectorClock::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int64 timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int64Size(
          this->timestamp());
    }
    
  }
  // repeated .voldemort.ClockEntry entries = 1;
  total_size += 1 * entries_size();
  for (int i = 0; i < entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->entries(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void VectorClock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VectorClock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VectorClock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VectorClock::MergeFrom(const VectorClock& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from._has_bit(1)) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VectorClock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VectorClock::CopyFrom(const VectorClock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VectorClock::Swap(VectorClock* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool VectorClock::IsInitialized() const {
  
  for (int i = 0; i < entries_size(); i++) {
    if (!this->entries(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* VectorClock::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* VectorClock::GetReflection() const {
  if (VectorClock_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return VectorClock_reflection_;
}

// ===================================================================

const ::std::string Versioned::_default_value_;

Versioned::Versioned()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    value_(const_cast< ::std::string*>(&_default_value_)),
    version_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void Versioned::InitAsDefaultInstance() {  version_ = const_cast< ::voldemort::VectorClock*>(&::voldemort::VectorClock::default_instance());
}

Versioned::Versioned(const Versioned& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    value_(const_cast< ::std::string*>(&_default_value_)),
    version_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

Versioned::~Versioned() {
  if (value_ != &_default_value_) {
    delete value_;
  }
  if (this != default_instance_) {
    delete version_;
  }
}

const ::google::protobuf::Descriptor* Versioned::descriptor() {
  if (Versioned_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return Versioned_descriptor_;
}

const Versioned& Versioned::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

Versioned* Versioned::default_instance_ = NULL;

Versioned* Versioned::New() const {
  return new Versioned;
}

void Versioned::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (value_ != &_default_value_) {
        value_->clear();
      }
    }
    if (_has_bit(1)) {
      if (version_ != NULL) version_->::voldemort::VectorClock::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Versioned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_value()));
        if (input->ExpectTag(18)) goto parse_version;
        break;
      }
      
      // required .voldemort.VectorClock version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_version:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_version()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool Versioned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes value = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->value(), output));
  }
  
  // required .voldemort.VectorClock version = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->version(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int Versioned::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->value());
    }
    
    // required .voldemort.VectorClock version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Versioned::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Versioned* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Versioned*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Versioned::MergeFrom(const Versioned& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_value(from.value());
    }
    if (from._has_bit(1)) {
      mutable_version()->::voldemort::VectorClock::MergeFrom(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Versioned::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Versioned::CopyFrom(const Versioned& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Versioned::Swap(Versioned* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Versioned::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_version()) {
    if (!this->version().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Versioned::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Versioned::GetReflection() const {
  if (Versioned_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return Versioned_reflection_;
}

// ===================================================================


const ::std::string Error::_default_error_message_;
Error::Error()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_code_(0),
    error_message_(const_cast< ::std::string*>(&_default_error_message_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void Error::InitAsDefaultInstance() {}

Error::Error(const Error& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_code_(0),
    error_message_(const_cast< ::std::string*>(&_default_error_message_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

Error::~Error() {
  if (error_message_ != &_default_error_message_) {
    delete error_message_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Error::descriptor() {
  if (Error_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return Error_descriptor_;
}

const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New() const {
  return new Error;
}

void Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
    if (_has_bit(1)) {
      if (error_message_ != &_default_error_message_) {
        error_message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required int32 error_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &error_code_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_error_message;
        break;
      }
      
      // required string error_message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_error_message:
        DO_(::google::protobuf::internal::WireFormat::ReadString(input, mutable_error_message()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required int32 error_code = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteInt32(1, this->error_code(), output));
  }
  
  // required string error_message = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteString(2, this->error_message(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int Error::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 error_code = 1;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->error_code());
    }
    
    // required string error_message = 2;
    if (has_error_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::StringSize(this->error_message());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Error::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Error* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Error*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Error::MergeFrom(const Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_error_code(from.error_code());
    }
    if (from._has_bit(1)) {
      set_error_message(from.error_message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::Swap(Error* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(error_message_, other->error_message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Error::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Error::GetReflection() const {
  if (Error_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return Error_reflection_;
}

// ===================================================================

const ::std::string KeyedVersions::_default_key_;

KeyedVersions::KeyedVersions()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void KeyedVersions::InitAsDefaultInstance() {}

KeyedVersions::KeyedVersions(const KeyedVersions& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

KeyedVersions::~KeyedVersions() {
  if (key_ != &_default_key_) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* KeyedVersions::descriptor() {
  if (KeyedVersions_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return KeyedVersions_descriptor_;
}

const KeyedVersions& KeyedVersions::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

KeyedVersions* KeyedVersions::default_instance_ = NULL;

KeyedVersions* KeyedVersions::New() const {
  return new KeyedVersions;
}

void KeyedVersions::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (key_ != &_default_key_) {
        key_->clear();
      }
    }
  }
  versions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyedVersions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_key()));
        if (input->ExpectTag(18)) goto parse_versions;
        break;
      }
      
      // repeated .voldemort.Versioned versions = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_versions:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_versions()));
        if (input->ExpectTag(18)) goto parse_versions;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool KeyedVersions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes key = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->key(), output));
  }
  
  // repeated .voldemort.Versioned versions = 2;
  for (int i = 0; i < versions_.size(); i++) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->versions(i), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int KeyedVersions::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->key());
    }
    
  }
  // repeated .voldemort.Versioned versions = 2;
  total_size += 1 * versions_size();
  for (int i = 0; i < versions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->versions(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void KeyedVersions::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyedVersions* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyedVersions*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyedVersions::MergeFrom(const KeyedVersions& from) {
  GOOGLE_CHECK_NE(&from, this);
  versions_.MergeFrom(from.versions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyedVersions::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyedVersions::CopyFrom(const KeyedVersions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyedVersions::Swap(KeyedVersions* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    versions_.Swap(&other->versions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool KeyedVersions::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < versions_size(); i++) {
    if (!this->versions(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* KeyedVersions::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* KeyedVersions::GetReflection() const {
  if (KeyedVersions_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return KeyedVersions_reflection_;
}

// ===================================================================

const ::std::string GetRequest::_default_key_;
GetRequest::GetRequest()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void GetRequest::InitAsDefaultInstance() {}

GetRequest::GetRequest(const GetRequest& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

GetRequest::~GetRequest() {
  if (key_ != &_default_key_) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* GetRequest::descriptor() {
  if (GetRequest_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetRequest_descriptor_;
}

const GetRequest& GetRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

GetRequest* GetRequest::default_instance_ = NULL;

GetRequest* GetRequest::New() const {
  return new GetRequest;
}

void GetRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (key_ != &_default_key_) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional bytes key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_key()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool GetRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // optional bytes key = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->key(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int GetRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->key());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void GetRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetRequest::MergeFrom(const GetRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetRequest::CopyFrom(const GetRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetRequest::Swap(GetRequest* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool GetRequest::IsInitialized() const {
  
  return true;
}

const ::google::protobuf::Descriptor* GetRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* GetRequest::GetReflection() const {
  if (GetRequest_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetRequest_reflection_;
}

// ===================================================================



GetResponse::GetResponse()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void GetResponse::InitAsDefaultInstance() {  error_ = const_cast< ::voldemort::Error*>(&::voldemort::Error::default_instance());
}

GetResponse::GetResponse(const GetResponse& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

GetResponse::~GetResponse() {
  if (this != default_instance_) {
    delete error_;
  }
}

const ::google::protobuf::Descriptor* GetResponse::descriptor() {
  if (GetResponse_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetResponse_descriptor_;
}

const GetResponse& GetResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

GetResponse* GetResponse::default_instance_ = NULL;

GetResponse* GetResponse::New() const {
  return new GetResponse;
}

void GetResponse::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (_has_bit(1)) {
      if (error_ != NULL) error_->::voldemort::Error::Clear();
    }
  }
  versioned_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // repeated .voldemort.Versioned versioned = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_versioned:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_versioned()));
        if (input->ExpectTag(10)) goto parse_versioned;
        if (input->ExpectTag(18)) goto parse_error;
        break;
      }
      
      // optional .voldemort.Error error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_error:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_error()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool GetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // repeated .voldemort.Versioned versioned = 1;
  for (int i = 0; i < versioned_.size(); i++) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->versioned(i), output));
  }
  
  // optional .voldemort.Error error = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->error(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int GetResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .voldemort.Error error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  // repeated .voldemort.Versioned versioned = 1;
  total_size += 1 * versioned_size();
  for (int i = 0; i < versioned_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->versioned(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void GetResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetResponse::MergeFrom(const GetResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  versioned_.MergeFrom(from.versioned_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from._has_bit(1)) {
      mutable_error()->::voldemort::Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetResponse::CopyFrom(const GetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetResponse::Swap(GetResponse* other) {
  if (other != this) {
    versioned_.Swap(&other->versioned_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool GetResponse::IsInitialized() const {
  
  for (int i = 0; i < versioned_size(); i++) {
    if (!this->versioned(i).IsInitialized()) return false;
  }
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* GetResponse::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* GetResponse::GetReflection() const {
  if (GetResponse_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetResponse_reflection_;
}

// ===================================================================


GetAllRequest::GetAllRequest()
  : ::google::protobuf::Message(),
    _cached_size_(0) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void GetAllRequest::InitAsDefaultInstance() {}

GetAllRequest::GetAllRequest(const GetAllRequest& from)
  : ::google::protobuf::Message(),
    _cached_size_(0) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

GetAllRequest::~GetAllRequest() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* GetAllRequest::descriptor() {
  if (GetAllRequest_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetAllRequest_descriptor_;
}

const GetAllRequest& GetAllRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

GetAllRequest* GetAllRequest::default_instance_ = NULL;

GetAllRequest* GetAllRequest::New() const {
  return new GetAllRequest;
}

void GetAllRequest::Clear() {
  keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetAllRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // repeated bytes keys = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_keys:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_keys()));
        if (input->ExpectTag(10)) goto parse_keys;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool GetAllRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // repeated bytes keys = 1;
  for (int i = 0; i < keys_.size(); i++) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->keys(i), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int GetAllRequest::ByteSize() const {
  int total_size = 0;
  
  // repeated bytes keys = 1;
  total_size += 1 * keys_size();
  for (int i = 0; i < keys_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->keys(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void GetAllRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetAllRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetAllRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetAllRequest::MergeFrom(const GetAllRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  keys_.MergeFrom(from.keys_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetAllRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAllRequest::CopyFrom(const GetAllRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAllRequest::Swap(GetAllRequest* other) {
  if (other != this) {
    keys_.Swap(&other->keys_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool GetAllRequest::IsInitialized() const {
  
  return true;
}

const ::google::protobuf::Descriptor* GetAllRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* GetAllRequest::GetReflection() const {
  if (GetAllRequest_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetAllRequest_reflection_;
}

// ===================================================================



GetAllResponse::GetAllResponse()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void GetAllResponse::InitAsDefaultInstance() {  error_ = const_cast< ::voldemort::Error*>(&::voldemort::Error::default_instance());
}

GetAllResponse::GetAllResponse(const GetAllResponse& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

GetAllResponse::~GetAllResponse() {
  if (this != default_instance_) {
    delete error_;
  }
}

const ::google::protobuf::Descriptor* GetAllResponse::descriptor() {
  if (GetAllResponse_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetAllResponse_descriptor_;
}

const GetAllResponse& GetAllResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

GetAllResponse* GetAllResponse::default_instance_ = NULL;

GetAllResponse* GetAllResponse::New() const {
  return new GetAllResponse;
}

void GetAllResponse::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (_has_bit(1)) {
      if (error_ != NULL) error_->::voldemort::Error::Clear();
    }
  }
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetAllResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // repeated .voldemort.KeyedVersions values = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_values:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_values()));
        if (input->ExpectTag(10)) goto parse_values;
        if (input->ExpectTag(18)) goto parse_error;
        break;
      }
      
      // optional .voldemort.Error error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_error:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_error()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool GetAllResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // repeated .voldemort.KeyedVersions values = 1;
  for (int i = 0; i < values_.size(); i++) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->values(i), output));
  }
  
  // optional .voldemort.Error error = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->error(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int GetAllResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .voldemort.Error error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  // repeated .voldemort.KeyedVersions values = 1;
  total_size += 1 * values_size();
  for (int i = 0; i < values_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->values(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void GetAllResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetAllResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetAllResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetAllResponse::MergeFrom(const GetAllResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  values_.MergeFrom(from.values_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from._has_bit(1)) {
      mutable_error()->::voldemort::Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetAllResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAllResponse::CopyFrom(const GetAllResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAllResponse::Swap(GetAllResponse* other) {
  if (other != this) {
    values_.Swap(&other->values_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool GetAllResponse::IsInitialized() const {
  
  for (int i = 0; i < values_size(); i++) {
    if (!this->values(i).IsInitialized()) return false;
  }
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* GetAllResponse::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* GetAllResponse::GetReflection() const {
  if (GetAllResponse_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return GetAllResponse_reflection_;
}

// ===================================================================

const ::std::string PutRequest::_default_key_;

PutRequest::PutRequest()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)),
    versioned_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void PutRequest::InitAsDefaultInstance() {  versioned_ = const_cast< ::voldemort::Versioned*>(&::voldemort::Versioned::default_instance());
}

PutRequest::PutRequest(const PutRequest& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)),
    versioned_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

PutRequest::~PutRequest() {
  if (key_ != &_default_key_) {
    delete key_;
  }
  if (this != default_instance_) {
    delete versioned_;
  }
}

const ::google::protobuf::Descriptor* PutRequest::descriptor() {
  if (PutRequest_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return PutRequest_descriptor_;
}

const PutRequest& PutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

PutRequest* PutRequest::default_instance_ = NULL;

PutRequest* PutRequest::New() const {
  return new PutRequest;
}

void PutRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (key_ != &_default_key_) {
        key_->clear();
      }
    }
    if (_has_bit(1)) {
      if (versioned_ != NULL) versioned_->::voldemort::Versioned::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_key()));
        if (input->ExpectTag(18)) goto parse_versioned;
        break;
      }
      
      // required .voldemort.Versioned versioned = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_versioned:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_versioned()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool PutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes key = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->key(), output));
  }
  
  // required .voldemort.Versioned versioned = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->versioned(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int PutRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->key());
    }
    
    // required .voldemort.Versioned versioned = 2;
    if (has_versioned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->versioned());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void PutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PutRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PutRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutRequest::MergeFrom(const PutRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_key(from.key());
    }
    if (from._has_bit(1)) {
      mutable_versioned()->::voldemort::Versioned::MergeFrom(from.versioned());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutRequest::CopyFrom(const PutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutRequest::Swap(PutRequest* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(versioned_, other->versioned_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool PutRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_versioned()) {
    if (!this->versioned().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* PutRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* PutRequest::GetReflection() const {
  if (PutRequest_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return PutRequest_reflection_;
}

// ===================================================================


PutResponse::PutResponse()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void PutResponse::InitAsDefaultInstance() {  error_ = const_cast< ::voldemort::Error*>(&::voldemort::Error::default_instance());
}

PutResponse::PutResponse(const PutResponse& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

PutResponse::~PutResponse() {
  if (this != default_instance_) {
    delete error_;
  }
}

const ::google::protobuf::Descriptor* PutResponse::descriptor() {
  if (PutResponse_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return PutResponse_descriptor_;
}

const PutResponse& PutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

PutResponse* PutResponse::default_instance_ = NULL;

PutResponse* PutResponse::New() const {
  return new PutResponse;
}

void PutResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (error_ != NULL) error_->::voldemort::Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional .voldemort.Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_error()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool PutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // optional .voldemort.Error error = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(1, this->error(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int PutResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .voldemort.Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void PutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PutResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PutResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutResponse::MergeFrom(const PutResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_error()->::voldemort::Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutResponse::CopyFrom(const PutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutResponse::Swap(PutResponse* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool PutResponse::IsInitialized() const {
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* PutResponse::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* PutResponse::GetReflection() const {
  if (PutResponse_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return PutResponse_reflection_;
}

// ===================================================================

const ::std::string DeleteRequest::_default_key_;

DeleteRequest::DeleteRequest()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)),
    version_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void DeleteRequest::InitAsDefaultInstance() {  version_ = const_cast< ::voldemort::VectorClock*>(&::voldemort::VectorClock::default_instance());
}

DeleteRequest::DeleteRequest(const DeleteRequest& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    key_(const_cast< ::std::string*>(&_default_key_)),
    version_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

DeleteRequest::~DeleteRequest() {
  if (key_ != &_default_key_) {
    delete key_;
  }
  if (this != default_instance_) {
    delete version_;
  }
}

const ::google::protobuf::Descriptor* DeleteRequest::descriptor() {
  if (DeleteRequest_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return DeleteRequest_descriptor_;
}

const DeleteRequest& DeleteRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

DeleteRequest* DeleteRequest::default_instance_ = NULL;

DeleteRequest* DeleteRequest::New() const {
  return new DeleteRequest;
}

void DeleteRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (key_ != &_default_key_) {
        key_->clear();
      }
    }
    if (_has_bit(1)) {
      if (version_ != NULL) version_->::voldemort::VectorClock::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeleteRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_key()));
        if (input->ExpectTag(18)) goto parse_version;
        break;
      }
      
      // required .voldemort.VectorClock version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_version:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_version()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool DeleteRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bytes key = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBytes(1, this->key(), output));
  }
  
  // required .voldemort.VectorClock version = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->version(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int DeleteRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->key());
    }
    
    // required .voldemort.VectorClock version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->version());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DeleteRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeleteRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeleteRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRequest::MergeFrom(const DeleteRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_key(from.key());
    }
    if (from._has_bit(1)) {
      mutable_version()->::voldemort::VectorClock::MergeFrom(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeleteRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRequest::CopyFrom(const DeleteRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRequest::Swap(DeleteRequest* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DeleteRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_version()) {
    if (!this->version().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* DeleteRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DeleteRequest::GetReflection() const {
  if (DeleteRequest_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return DeleteRequest_reflection_;
}

// ===================================================================



DeleteResponse::DeleteResponse()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    success_(false),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void DeleteResponse::InitAsDefaultInstance() {  error_ = const_cast< ::voldemort::Error*>(&::voldemort::Error::default_instance());
}

DeleteResponse::DeleteResponse(const DeleteResponse& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    success_(false),
    error_(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

DeleteResponse::~DeleteResponse() {
  if (this != default_instance_) {
    delete error_;
  }
}

const ::google::protobuf::Descriptor* DeleteResponse::descriptor() {
  if (DeleteResponse_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return DeleteResponse_descriptor_;
}

const DeleteResponse& DeleteResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

DeleteResponse* DeleteResponse::default_instance_ = NULL;

DeleteResponse* DeleteResponse::New() const {
  return new DeleteResponse;
}

void DeleteResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    success_ = false;
    if (_has_bit(1)) {
      if (error_ != NULL) error_->::voldemort::Error::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DeleteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bool success = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBool(
              input, &success_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_error;
        break;
      }
      
      // optional .voldemort.Error error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_error:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_error()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool DeleteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required bool success = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBool(1, this->success(), output));
  }
  
  // optional .voldemort.Error error = 2;
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->error(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int DeleteResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool success = 1;
    if (has_success()) {
      total_size += 1 + 1;
    }
    
    // optional .voldemort.Error error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->error());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DeleteResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DeleteResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DeleteResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteResponse::MergeFrom(const DeleteResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_success(from.success());
    }
    if (from._has_bit(1)) {
      mutable_error()->::voldemort::Error::MergeFrom(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DeleteResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteResponse::CopyFrom(const DeleteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteResponse::Swap(DeleteResponse* other) {
  if (other != this) {
    std::swap(success_, other->success_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DeleteResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* DeleteResponse::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DeleteResponse::GetReflection() const {
  if (DeleteResponse_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return DeleteResponse_reflection_;
}

// ===================================================================



const ::std::string VoldemortRequest::_default_store_;




VoldemortRequest::VoldemortRequest()
  : ::google::protobuf::Message(),
    _cached_size_(0),
    type_(0),
    should_route_(false),
    store_(const_cast< ::std::string*>(&_default_store_)),
    get_(NULL),
    getall_(NULL),
    put_(NULL),
    delete__(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

void VoldemortRequest::InitAsDefaultInstance() {  get_ = const_cast< ::voldemort::GetRequest*>(&::voldemort::GetRequest::default_instance());
  getall_ = const_cast< ::voldemort::GetAllRequest*>(&::voldemort::GetAllRequest::default_instance());
  put_ = const_cast< ::voldemort::PutRequest*>(&::voldemort::PutRequest::default_instance());
  delete__ = const_cast< ::voldemort::DeleteRequest*>(&::voldemort::DeleteRequest::default_instance());
}

VoldemortRequest::VoldemortRequest(const VoldemortRequest& from)
  : ::google::protobuf::Message(),
    _cached_size_(0),
    type_(0),
    should_route_(false),
    store_(const_cast< ::std::string*>(&_default_store_)),
    get_(NULL),
    getall_(NULL),
    put_(NULL),
    delete__(NULL) {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  MergeFrom(from);
}

VoldemortRequest::~VoldemortRequest() {
  if (store_ != &_default_store_) {
    delete store_;
  }
  if (this != default_instance_) {
    delete get_;
    delete getall_;
    delete put_;
    delete delete__;
  }
}

const ::google::protobuf::Descriptor* VoldemortRequest::descriptor() {
  if (VoldemortRequest_descriptor_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return VoldemortRequest_descriptor_;
}

const VoldemortRequest& VoldemortRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return *default_instance_;
}

VoldemortRequest* VoldemortRequest::default_instance_ = NULL;

VoldemortRequest* VoldemortRequest::New() const {
  return new VoldemortRequest;
}

void VoldemortRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    should_route_ = false;
    if (_has_bit(2)) {
      if (store_ != &_default_store_) {
        store_->clear();
      }
    }
    if (_has_bit(3)) {
      if (get_ != NULL) get_->::voldemort::GetRequest::Clear();
    }
    if (_has_bit(4)) {
      if (getall_ != NULL) getall_->::voldemort::GetAllRequest::Clear();
    }
    if (_has_bit(5)) {
      if (put_ != NULL) put_->::voldemort::PutRequest::Clear();
    }
    if (_has_bit(6)) {
      if (delete__ != NULL) delete__->::voldemort::DeleteRequest::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VoldemortRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required .voldemort.RequestType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (voldemort::RequestType_IsValid(value)) {
          set_type(static_cast< voldemort::RequestType >(value));
        } else {
          mutable_unknown_fields()->AddField(1)->add_varint(value);
        }
        if (input->ExpectTag(16)) goto parse_should_route;
        break;
      }
      
      // required bool should_route = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_should_route:
        DO_(::google::protobuf::internal::WireFormat::ReadBool(
              input, &should_route_));
        _set_bit(1);
        if (input->ExpectTag(26)) goto parse_store;
        break;
      }
      
      // required string store = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_store:
        DO_(::google::protobuf::internal::WireFormat::ReadString(input, mutable_store()));
        if (input->ExpectTag(34)) goto parse_get;
        break;
      }
      
      // optional .voldemort.GetRequest get = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_get:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_get()));
        if (input->ExpectTag(42)) goto parse_getAll;
        break;
      }
      
      // optional .voldemort.GetAllRequest getAll = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_getAll:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_getall()));
        if (input->ExpectTag(50)) goto parse_put;
        break;
      }
      
      // optional .voldemort.PutRequest put = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_put:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_put()));
        if (input->ExpectTag(58)) goto parse_delete;
        break;
      }
      
      // optional .voldemort.DeleteRequest delete = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_delete:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, mutable_delete_()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

bool VoldemortRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  // required .voldemort.RequestType type = 1;
  if (_has_bit(0)) {
    DO_(::google::protobuf::internal::WireFormat::WriteEnum(1, this->type(), output));
  }
  
  // required bool should_route = 2 [default = false];
  if (_has_bit(1)) {
    DO_(::google::protobuf::internal::WireFormat::WriteBool(2, this->should_route(), output));
  }
  
  // required string store = 3;
  if (_has_bit(2)) {
    DO_(::google::protobuf::internal::WireFormat::WriteString(3, this->store(), output));
  }
  
  // optional .voldemort.GetRequest get = 4;
  if (_has_bit(3)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->get(), output));
  }
  
  // optional .voldemort.GetAllRequest getAll = 5;
  if (_has_bit(4)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(5, this->getall(), output));
  }
  
  // optional .voldemort.PutRequest put = 6;
  if (_has_bit(5)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(6, this->put(), output));
  }
  
  // optional .voldemort.DeleteRequest delete = 7;
  if (_has_bit(6)) {
    DO_(::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(7, this->delete_(), output));
  }
  
  if (!unknown_fields().empty()) {
    DO_(::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output));
  }
  return true;
#undef DO_
}

int VoldemortRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .voldemort.RequestType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->type());
    }
    
    // required bool should_route = 2 [default = false];
    if (has_should_route()) {
      total_size += 1 + 1;
    }
    
    // required string store = 3;
    if (has_store()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::StringSize(this->store());
    }
    
    // optional .voldemort.GetRequest get = 4;
    if (has_get()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->get());
    }
    
    // optional .voldemort.GetAllRequest getAll = 5;
    if (has_getall()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->getall());
    }
    
    // optional .voldemort.PutRequest put = 6;
    if (has_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->put());
    }
    
    // optional .voldemort.DeleteRequest delete = 7;
    if (has_delete_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
          this->delete_());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void VoldemortRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VoldemortRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VoldemortRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VoldemortRequest::MergeFrom(const VoldemortRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_type(from.type());
    }
    if (from._has_bit(1)) {
      set_should_route(from.should_route());
    }
    if (from._has_bit(2)) {
      set_store(from.store());
    }
    if (from._has_bit(3)) {
      mutable_get()->::voldemort::GetRequest::MergeFrom(from.get());
    }
    if (from._has_bit(4)) {
      mutable_getall()->::voldemort::GetAllRequest::MergeFrom(from.getall());
    }
    if (from._has_bit(5)) {
      mutable_put()->::voldemort::PutRequest::MergeFrom(from.put());
    }
    if (from._has_bit(6)) {
      mutable_delete_()->::voldemort::DeleteRequest::MergeFrom(from.delete_());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VoldemortRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VoldemortRequest::CopyFrom(const VoldemortRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VoldemortRequest::Swap(VoldemortRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(should_route_, other->should_route_);
    std::swap(store_, other->store_);
    std::swap(get_, other->get_);
    std::swap(getall_, other->getall_);
    std::swap(put_, other->put_);
    std::swap(delete__, other->delete__);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool VoldemortRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_put()) {
    if (!this->put().IsInitialized()) return false;
  }
  if (has_delete_()) {
    if (!this->delete_().IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* VoldemortRequest::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* VoldemortRequest::GetReflection() const {
  if (VoldemortRequest_reflection_ == NULL) protobuf_BuildDesc_voldemort_2dclient_2eproto();
  return VoldemortRequest_reflection_;
}

}  // namespace voldemort
